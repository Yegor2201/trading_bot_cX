// Global state
let refreshInterval;
let isLoading = false;
const UPDATE_INTERVAL = 5000; // 5 seconds

// Utility functions
function formatNumber(num, decimals = 4) {
    return Number(num).toLocaleString('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals
    });
}

function formatPrice(price) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(price);
}

function formatPnL(pnl) {
    const num = parseFloat(pnl);
    const formatted = formatNumber(Math.abs(num), 2);
    return `${num >= 0 ? '+' : '-'}${formatted}%`;
}

// UI state management
function showLoading() {
    isLoading = true;
    document.querySelectorAll('.loading-overlay').forEach(el => {
        el.style.display = 'flex';
    });
}

function hideLoading() {
    isLoading = false;
    document.querySelectorAll('.loading-overlay').forEach(el => {
        el.style.display = 'none';
    });
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.classList.add('show');
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }, 100);
}

// Data updates
async function updateMetrics() {
    try {
        const response = await fetch('/metrics');
        if (!response.ok) throw new Error('Failed to fetch metrics');
        
        const data = await response.json();
        if (data.error) throw new Error(data.error);
        
        // Update balance with animation
        const balanceEl = document.getElementById('balance');
        const oldBalance = parseFloat(balanceEl.textContent.replace(/[^0-9.-]+/g, "") || "0");
        const newBalance = data.balance;
        
        balanceEl.textContent = formatPrice(newBalance);
        
        if (oldBalance !== newBalance && oldBalance !== 0) {
            balanceEl.classList.remove('increase', 'decrease');
            void balanceEl.offsetWidth; // Force reflow
            balanceEl.classList.add(newBalance > oldBalance ? 'increase' : 'decrease');
            setTimeout(() => balanceEl.classList.remove('increase', 'decrease'), 1000);
        }
        
        // Update metrics with animations
        const metrics = {
            'win-rate': { value: data.win_rate, format: v => `${v}%`, threshold: 50 },
            'profit-factor': { value: data.profit_factor, format: v => v.toFixed(2), threshold: 1 },
            'drawdown': { value: data.max_drawdown, format: v => `${v}%`, threshold: 20, inverse: true }
        };
        
        Object.entries(metrics).forEach(([id, { value, format, threshold, inverse }]) => {
            const el = document.getElementById(id);
            el.textContent = format(value);
            el.className = inverse ? 
                (value <= threshold ? 'success' : 'warning') :
                (value >= threshold ? 'success' : 'warning');
        });
        
    } catch (error) {
        console.error('Failed to update metrics:', error);
        ['balance', 'win-rate', 'profit-factor', 'drawdown'].forEach(id => {
            document.getElementById(id).textContent = '-';
        });
    }
}

async function updateTrades() {
    if (isLoading) return;
    showLoading();
    
    try {
        // Update metrics first
        await updateMetrics();
        
        // Fetch trades
        const response = await fetch('/trades');
        if (!response.ok) throw new Error('Failed to fetch trades');
        
        const trades = await response.json();
        
        // Update tables
        updateTradeTable('active-trades', trades.active_trades || [], true);
        updateTradeTable('closed-trades', trades.closed_trades || [], false);
        
    } catch (error) {
        console.error('Failed to update trades:', error);
        showNotification('Failed to update trades', 'error');
    } finally {
        hideLoading();
    }
}

function updateTradeTable(tableId, trades, isActive) {
    const table = document.getElementById(tableId).querySelector('tbody');
    
    if (!trades.length) {
        table.innerHTML = `<tr><td colspan="6" class="no-data">No ${isActive ? 'active positions' : 'trade history'}</td></tr>`;
        return;
    }
    
    table.innerHTML = trades.map(trade => `
        <tr>
            <td><span class="symbol">${trade[1]}</span></td>
            <td><span class="badge ${trade[2].toLowerCase()}">${trade[2]}</span></td>
            <td>${formatNumber(trade[3])}</td>
            <td>${formatPrice(trade[4])}</td>
            <td>${isActive ? formatPrice(trade[5]) : formatPrice(trade[5])}</td>
            <td class="${parseFloat(trade[6]) >= 0 ? 'profit' : 'loss'}">${formatPnL(trade[6])}</td>
        </tr>
    `).join('');
}

// Bot control
async function startBot() {
    try {
        const response = await fetch('/start', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to start bot');
        
        const data = await response.json();
        showNotification('Bot started successfully', 'success');
        
        // Start periodic updates
        refreshInterval = setInterval(updateTrades, UPDATE_INTERVAL);
        
        // Initial update
        updateTrades();
        
        // Update button states
        document.querySelector('button[onclick="startBot()"]').disabled = true;
        document.querySelector('button[onclick="stopBot()"]').disabled = false;
        
    } catch (error) {
        console.error('Failed to start bot:', error);
        showNotification('Failed to start bot', 'error');
    }
}

function stopBot() {
    clearInterval(refreshInterval);
    showNotification('Bot stopped', 'info');
    
    // Update button states
    document.querySelector('button[onclick="startBot()"]').disabled = false;
    document.querySelector('button[onclick="stopBot()"]').disabled = true;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    // Add loading overlays to tables
    ['active-trades', 'closed-trades'].forEach(id => {
        const table = document.getElementById(id);
        const overlay = document.createElement('div');
        overlay.className = 'loading-overlay';
        overlay.innerHTML = '<div class="loading-spinner"></div>';
        table.parentElement.style.position = 'relative';
        table.parentElement.appendChild(overlay);
    });
    
    // Initial data load
    updateTrades();
});
